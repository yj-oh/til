# 브랜칭 전략 - 개인적 경험
- 이직을 했다. 새로운 사람들과 협업 하는 방식을 정해가는 중. 
- 당연히 Git 브랜칭 전략에 대한 논의도 있었다.
- 이전 경험들을 되짚다보니 항상 다른 방법으로 깃을 써왔다는 생각이 들었다.
- 마침 며칠 전 오대리가 물어봐서 간략하게 그동안의 경험을 공유했었다.
- 한 번쯤 정리해두면 좋겠다는 생각이 들어서 정리한다.
- 일반적인 Git flow, GitHub flow, GitLab flow 에 대해서는 워낙 자료가 풍부해서
  따로 정리하지는 않는다. 아래 링크 참고.
  - [Git flow, GitHub flow, GitLab flow](https://ujuc.github.io/2015/12/16/git-flow-github-flow-gitlab-flow/)
  - [Git 브랜칭 전략 : Git-flow와 Github-flow](https://hellowoori.tistory.com/56)
  - [우아한형제들 기술 블로그 - 우린 Git-flow를 사용하고 있어요](https://techblog.woowahan.com/2553/)

---

# 🔧 1. Single branch 사용
- `master` 하나의 브랜치만 사용.
- 모든 팀원이 즉각적으로 push 하여 작업 상황 공유.
- 원격지에 올라간 코드를 수동으로 빌드하여 운영기/개발기에 각각 배포.

## 👍 장점
- 간편/편리/쉬움
- git 초심자에게도 부담 없음
- git 관리에 많은 비용이 들지 않음
- 팀원들의 작업 상황을 즉각 파악 가능

## 👎 단점
- 자동 배포 시스템 구축 불가능
- push 한 코드에 문제가 있을 경우 방어책 X
- git 을 코드 리뷰에 활용할 수 없음
- 단순 backup 시스템과 다를 바 없음

## 💭 개인적 감상
- 팀 규모가 작았다.
- 충돌에 대한 문제가 분명 있을 수 있는데 왜 진땀 흘린 기억이 없을까 생각해보니
  개발자 각각이 다른 repo 에서 작업했었던 듯.
- 이제 막 실무에 뛰어들어서 Git 에 대한 이해도도 높지 않았고 소스 꼬여서 다 날릴까봐
  무서워하기까지 했던 때였으나 하도 단순한 사용 방식이라 금세 익숙해졌다.
- Git 이 가진 무수한 장점을 사용하지 않는 방식이다.
- 그때 당시에는 그냥 좋은 거고 뭐고 시키는 대로, 정해진 대로 따라가기 바빴는데
  이 방식을 다시 실무에서 쓸 일은 없지 않을까.

# 🔧 2. GitLab flow 응용
## ※ GitLab flow
- https://docs.gitlab.com/ee/topics/gitlab_flow.html
- 'Git flow 는 너무 복잡하고 GitHub flow 는 너무 단순하다.'
- GitHub flow 가 가지는 한계, 이슈 등을 보완하기 위한 방법.
  - 코드 병합과 서비스 배포를 분리할 수 없다는 한계.
  - 릴리스 시기를 컨트롤 할 수 없다는 한계. (e.g iOS application)
- 배포된 코드를 반영하는 `production` 브랜치를 둔다.
  - GitHub flow 의 `master` 브랜치가 이 `production` 브랜치다.
  - ![GitLab flow 1](.%5B20211012%5D_git_branching_workflows_images/6a17baf5.png)
- 한 단계 더, `pre-production`을 두기도 한다.
  - ![GitLab flow 2](.%5B20211012%5D_git_branching_workflows_images/e97ab1e7.png)

## 💡 이렇게 사용했다
- `local`, `develop`, `master` 세 개의 필수 브랜치.
  - `local` : 작업자들끼리의 코드 통합
  - `develop` : 병합 시 개발기에 자동 배포
  - `master` : 병합 시 운영기에 자동 배포
  - [필요 시] feature 브랜치 : `local`에서 필요에 따라 자유롭게 분기하며 반드시 `local`로 병합되어야 한다.

### master
- 실제 돌아가는 운영 코드와 동일 (merge == 배포)
- 언제든 배포 가능한 상태 유지
- 직접 push 불가능, `develop` 브랜치와 병합만 가능.
- 병합되는 커밋 지점들은 버전으로 관리되어야 함.
- 운영에 자동 배포 되는 브랜치이므로 매우 엄격한 규칙 적용.

### develop
- 내부 테스트를 위한 개발기 코드와 동일.
- 운영기에 배포되는 시점은 이 브랜치에서 결정.

### local
- 실질적인 작업 공간.
- 모든 팀원이 수시로 commit, push 하여 작업 상황 공유.
- 필요에 따라 자유롭게 feature 브랜치 분기.
- 코드 리뷰 후 필요에 따라 자유롭게 `develop` 브랜치로 병합.

## 👍 장점
- 기본적으로 CI/CD 를 내포하고 있다.
- 코드 통합과 테스트와 배포를 분리 : 릴리스된 코드가 항상 최신 버전의 코드일 필요가 없다.
- history 파악에 용이 : 운영기와 개발기 각각에 대한 명확한 병합, 배포 시점 관리 가능
- 엄격한 테스트 환경 제공 : 작업자간 코드가 통합되는 브랜치와 운영기에 자동 배포되는 
  `master` 브랜치 사이에 `develop` 브랜치를 반드시 거치게 함으로써 모든 코드에 대한
  다양한 환경에서의 엄격한 테스트와 버그 픽스 가능.
- 원하는 부분만, 원하는 시기에 릴리스 배포 가능.
- 개발기/운영기로의 코드 병합 피로도 감소
  - 모든 코드 충돌은 `local` 브랜치에서 발생, 해결된 후 각각으로 단순 배포되므로
    배포 시에는 기능의 정상 동작 여부 등에만 집중할 수 있다.

## 👎 단점
- 작업자들의 Git 이해도가 어느 정도 있어야 함. 그렇지 않을 경우 혼선이 있을 수 있다.
- GitHub flow 보다 복잡하게 느껴질 수 있다.
- GitHub flow 보다 추가된 브랜치를 사용하므로 관리 비용도 추가됨.

## 💡 이 방법을 채택한 이유
- 맨땅에서 새로 개발하는 프로젝트를 시작하면서 브랜칭 전략에 대한 고민을 했었다.
- Git flow, GitHub flow, GitLab flow 을 모두 검토함.
  - Git flow 는 수시로 배포하며 액티브하게 돌아가야 했던 당시의 시스템에는 
    너무 복잡한 방법이라는 생각이 들어서 pass
  - GitHub flow 는 간편하지만 여러 기능이 동시다발적으로 바쁘게 개발되고 있는 최신 상태, 
    개발기에서 내부 통합 테스트를 진행해야 하는 상태, 
    실제로 운영기에 배포해서 굴려야 하는 상태 각각을 유연하면서도 명확하게 컨트롤 하기에는
    한계가 있다는 생각이 들었다.

## 💭 개인적 감상
- 전략 자체의 문제점은 잘 느끼지 못했음. 다만 작업자들 간의 Git 이해도 차이 등은
  맞출 필요가 있었다.
- 기본 전제가 모든 코드에 대한 코드 리뷰, 테스트이므로
  정말 작은 기능 하나 호다닥 고쳐서 호다닥 빠르게 배포하기에는 걸리적거릴 수 있다.
- 기본 필수 브랜치가 더 많고 몇 가지 규칙이 더 생기지만 코드 관리, 개발기 테스트, 
  운영 환경 관리가 매우 명확해져서 관리 비용이 증가한다는 점에 동의하지 않았었다.
- 다만 작업자간 코드 통합시 히스토리를 잘 관리하지 않으면 지옥이 펼쳐질 수 있다는 걸 어깨 너머로 지켜봄. 
  아마 몇 가지 규칙이 더 필요했을 수도...?

# 🔧 3. GitHub flow
- 이번에 써보게 될 전략.
- 설명을 들었고 자료도 찾아봤지만 운영기/개발기 배포 프로세스 및 테스트, 버전 관리가
  그래서 구체적으로 어떻게 된다는 건지 잘 모르겠어서 일단 도움을 받아 해보기로 함.
- GitLab flow 보다 더 간단한 전략이라고 하니 기대 중.

### +) GitHub flow 세 달 운영해본 후 내용 추가
## 💡 이렇게 사용했다
- 작업자 2-3명
- 각 작업자는 `main` 브랜치에서 자유롭게 브랜치 분기
- 반드시 PR 생성하여 코드 리뷰 후 `main` 브랜치에 병합 (rebase merge)
- 병합된 feature 브랜치는 자동 삭제
- `main` 브랜치에 병합되면 개발기 자동 배포
- `main` 브랜치에 태그가 달리면 운영기 자동 배포

## 👍 장점
- [Single branch](#-1-single-branch-사용) 의 장점
  - 간편/편리/쉬움
  - git 초심자에게도 부담 없음
  - git 관리에 많은 비용이 들지 않음
  - 팀원들의 작업 상황을 즉각 파악 가능
- 그러면서 [Single branch](#-1-single-branch-사용) 의 단점 보완
  - 자동 배포 시스템 구축 ~~불가능~~ → 가능
  - git 을 코드 리뷰에 활용할 수 ~~없음~~ → 활용 가능
  - push 한 코드에 문제가 있을 경우 ~~방어책 X~~ → 코드 리뷰를 통해 방어 가능
  - ~~단순 backup 시스템과 다를 바 없음~~

## 👎 단점
- 아무리 개발기는 개발기라지만 배포 단위를 관리할 수 있으면 더 좋겠다.
- 소프트웨어와 팀 단위가 커질 때에도 수월하게 운영될 수 있을까?

## 💭 개인적 감상
- 현재의 팀은 Rebase merge 방식을 채택했는데 병합 후 각각의 커밋이 덩어리로 파악되지 않고 
  흩뿌려진 모습이라(like 인도 쌀) 히스토리 파악이 직관적이지는 않음.
  - PR 단위를 의미있게 잡았다면 Merge commit 을 생성하는 것이 더 좋겠다는 생각이 듦.
  - 그렇게 되면 히스토리가 일자로 쭉 뻗은 히스토리보다야 복잡해보일 `수도` 있겠다만
    정작 히스토리 파악할 때는 더 직관적으로 읽을 수 있을 것.
- 작은 팀이고 백엔드는 주 작업자가 나 포함 2명 뿐이라 GitHub flow 는 작업 방식이 간편해서 좋지만
  소프트웨어와 팀 단위가 무거워질수록 디테일한 관리가 어려워지지 않을까 하는 의구심이 듦.
- 태그를 이용한 자동 배포 : 소프트웨어 버전 관리 + 배포를 한방에, 아주 간편.

---

## 현재 진행 중인 가계부 프로젝트의 브랜치 정책
- 위의 경험들을 종합해서, 개인 프로젝트에서는 이렇게 하기로 했다.

## 💡 이렇게 사용한다
- `main` 하나의 브랜치 사용
- `main` 브랜치에서 자유롭게 브랜치 분기
- 병합할 때 Merge commit 생성 : `Merge branch '<branch-name>' : [Description]` 
  → 개발기 배포 단위로 관리
- Merge commit 에 `v*.*.*` 태그 생성 
  → 운영기 배포 단위로 관리
- 병합된 브랜치 삭제
- 브랜치는 반드시 분기한 base 브랜치로 병합한다 (건너뛰지 않는다)
